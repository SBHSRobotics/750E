/*
 * autonWriter.c
 *
 *  Created on: Nov 7, 2014
 *      Author: Matthew
 */

#include "main.h"

FILE* outputFile;

void printLicense(void) {
	fprint("/** @file auto.c\n", outputFile);
	fprint(" * @brief File for autonomous code\n", outputFile);
	fprint(" *\n", outputFile);
	fprint(" * This file should contain the user autonomous() function and any functions related to it.\n", outputFile);
	fprint(" *\n", outputFile);
	fprint(" * Copyright (c) 2011-2014, Purdue University ACM SIG BOTS.\n", outputFile);
	fprint(" * All rights reserved.\n", outputFile);
	fprint(" *\n", outputFile);
	fprint(" * Redistribution and use in source and binary forms, with or without\n", outputFile);
	fprint(" * modification, are permitted provided that the following conditions are met:\n", outputFile);
	fprint(" *     * Redistributions of source code must retain the above copyright\n", outputFile);
	fprint(" *       notice, this list of conditions and the following disclaimer.\n", outputFile);
	fprint(" *     * Redistributions in binary form must reproduce the above copyright\n", outputFile);
	fprint(" *       notice, this list of conditions and the following disclaimer in the\n", outputFile);
	fprint(" *       documentation and/or other materials provided with the distribution.\n", outputFile);
	fprint(" *     * Neither the name of Purdue University ACM SIG BOTS nor the\n", outputFile);
	fprint(" *       names of its contributors may be used to endorse or promote products\n", outputFile);
	fprint(" *       derived from this software without specific prior written permission.\n", outputFile);
	fprint(" *\n", outputFile);
	fprint(" * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n", outputFile);
	fprint(" * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n", outputFile);
	fprint(" * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n", outputFile);
	fprint(" * DISCLAIMED. IN NO EVENT SHALL PURDUE UNIVERSITY ACM SIG BOTS BE LIABLE FOR ANY\n", outputFile);
	fprint(" * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n", outputFile);
	fprint(" * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n", outputFile);
	fprint(" * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n", outputFile);
	fprint(" * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n", outputFile);
	fprint(" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n", outputFile);
	fprint(" * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n", outputFile);
	fprint(" *\n", outputFile);
	fprint(" * Purdue Robotics OS contains FreeRTOS (http://www.freertos.org) whose source code may be\n", outputFile);
	fprint(" * obtained from http://sourceforge.net/projects/freertos/files/ or on request.\n", outputFile);
	fprint(" */\n", outputFile);
	fprint("\n", outputFile);
	delay(20);
}

void printGenMessage(void) {
	fprint("// Code automatically generated by 750Evo\n", outputFile);
	fprint("\n", outputFile);
	delay(20);
}

void printIncludes(void) {
	fprint("#include \"main.h\"\n\n", outputFile);
}

void printTimerLibrary(void) {
	fprint("// ------------------ TIMERS --------------------\n", outputFile);
	fprint("#define NUM_TIMERS 10\n", outputFile);
	fprint("long milliTimers[NUM_TIMERS];\n", outputFile);
	fprint("long microTimers[NUM_TIMERS];\n", outputFile);
	fprint("bool stopped[NUM_TIMERS];\n\n", outputFile);

	fprint("void startTimer(int num, bool useMilli) {\n", outputFile);
	fprint("\tif (useMilli) {\n", outputFile);
	fprint("\t\tmilliTimers[num] = millis();\n", outputFile);
	fprint("\t} else {\n", outputFile);
	fprint("\t\tmicroTimers[num] = micros();\n", outputFile);
	fprint("\t}\n", outputFile);
	fprint("\tif (stopped[num]) {\n", outputFile);
	fprint("\t\tstopped[num] = false;\n", outputFile);
	fprint("\t}\n", outputFile);
	fprint("}\n", outputFile);
	fprint("\n", outputFile);
	fprint("long getTimer(int num, bool useMilli) {\n", outputFile);
	fprint("\tif (stopped[num]) {\n", outputFile);
	fprint("\t\treturn 0;\n", outputFile);
	fprint("\t}\n", outputFile);
	fprint("\n", outputFile);
	fprint("\tif (useMilli) {\n", outputFile);
	fprint("\t\treturn millis() - milliTimers[num];\n", outputFile);
	fprint("\t} else {\n", outputFile);
	fprint("\t\treturn micros() - microTimers[num];\n", outputFile);
	fprint("\t}\n", outputFile);
	fprint("}\n", outputFile);
	fprint("\n", outputFile);
	fprint("long lapTimer(int num, bool useMilli) {\n", outputFile);
	fprint("\tif (stopped[num]) {\n", outputFile);
	fprint("\t\treturn 0;\n", outputFile);
	fprint("\t}\n", outputFile);
	fprint("\n", outputFile);
	fprint("\tlong returnVal = getTimer(num, useMilli);\n", outputFile);
	fprint("\tstartTimer(num, useMilli);\n", outputFile);
	fprint("\treturn returnVal;\n", outputFile);
	fprint("}\n", outputFile);
	fprint("\n", outputFile);
	fprint("void stopTimer(int num) {\n", outputFile);
	fprint("\tstopped[num] = true;\n", outputFile);
	fprint("}\n", outputFile);
	fprint("// ------------------ TIMERS --------------------\n", outputFile);
	fprint("\n", outputFile);
	delay(20);
}

void printGlobalSensors(void) {
	for (int i = 1; i < numPairs; i++) {
		//Sensor *sensors = pairMap[i].sensors;
		for (int j = 0; j < pairMap[i].numSensors; j++) {
			Sensor sensor = pairMap[i].sensors[j];
			switch (sensor.type) {
			case SHAFT_ENCODER:
				fprintf(outputFile, "Encoder pair_%d_%d_enc = encoderInit(%d, %d + 1, false);\n", i, j, sensor.port, sensor.port);
				break;
			case GYROSCOPE:
				fprintf(outputFile, "Gyro pair_%d_%d_gyro = gyroInit(%d, 0);\n", i, j, sensor.port);
				break;
			case ULTRASONIC:
				fprintf(outputFile, "Ultrasonic pair_%d_%d_ult = ultrasonicInit(%d, %d + 1);\n", i, j, sensor.port, sensor.port);
				break;
			default:
				break;
			}
		}
	}
	fprint("\n", outputFile);
	delay(20);
}

void getSensorGetFunc(MotorSensorPair pair, Sensor sensor, int sensorIndex, char *inStr) {
	switch (sensor.type) {
	case SHAFT_ENCODER:
		sprintf(inStr, "encoderGet(pair_%d_%d_nc)", pair.pairId, sensorIndex);
		break;
	case GYROSCOPE:
		sprintf(inStr, "gyroGet(pair_%d_%d_gyr)", pair.pairId, sensorIndex);
		break;
	case ULTRASONIC:
		sprintf(inStr, "ultrasonicGet(pair_%d_%d_ult)", pair.pairId, sensorIndex);
		break;
	case ACCELEROMETER:
		sprintf(inStr, "analogReadCalibratedHR(%d)", sensor.port);
		break;
	case BUMPER_SWITCH:
	case LIMIT_SWITCH:
		sprintf(inStr, "digitalRead(%d)", sensor.port);
		break;
	case LINE_TRACKER:
	case POTENTIOMETER:
		sprintf(inStr, "analogRead(%d)", sensor.port);
		break;
	case TIME:
		sprintf(inStr, "getTimer(%d, true)", sensor.port);
		break;
	default:
		break;
	}
}

void getSensorInitFunc(MotorSensorPair pair, Sensor sensor, int sensorIndex, char *inStr) {
	switch (sensor.type) {
	case TIME:
		sprintf(inStr, "\tstartTimer(%d, true);\n", sensor.port);
		break;
	case SHAFT_ENCODER:
		sprintf(inStr, "\tencoderReset(pair_%d_%d_enc);\n", sensorIndex, pair.pairId);
		break;
	case IME:
		sprintf(inStr, "\timeReset(%d);\n", sensor.port);
		break;
	default:
		break;
	}
}

void printMotorPairs(void) {
	for (int i = 1; i < numPairs; i++) {
		MotorSensorPair pair = pairMap[i];
		fprintf(outputFile, "void movePair%d(void *data) {\n", i);
		fprint("\tint ***dataPointer = (int ***)data;\n", outputFile);
		fprint("\tint **points = *dataPointer;\n", outputFile);
		fprint("\tint numPoints = points[0][0];\n", outputFile);
		fprintf(outputFile, "\tnextPoint[%d] = 1;\n", i - 1);
		fprint("\t\n", outputFile);

		char *str;
		for (int j = 0; j < pair.numSensors; j++) {
			str = malloc(20 * sizeof(char));
			str[0] = 0;
			getSensorInitFunc(pair, pair.sensors[j], j, str);
			if (str[0] != 0) {
				fprint(str, outputFile);
			}
			free(str);
		}
		for (int j = 0; j < pair.numPorts; j++) {
			fprintf(outputFile, "\tmotorSet(%d, points[nextPoint[%d]][%d]);\n", pair.motorPorts[j], i - 1, j);
		}
		fprintf(outputFile, "\tnextPoint[%d]++;\n", i - 1);

		fprint("\n", outputFile);
		fprintf(outputFile, "\tint *dir = malloc(%d * sizeof(int));\n", pair.numSensors);
		fprintf(outputFile, "\tfor (int i = 0; i < %d; i++) {\n", pair.numSensors);
		fprintf(outputFile, "\t\tdir[i] = (abs(points[nextPoint[%d]][%d + i]) - abs(points[nextPoint[%d] - 1][%d + i]) >= 0 ? 1 : -1);\n",
				i - 1, pair.numPorts, i - 1, pair.numPorts);
		fprint("\t}\n", outputFile);
		fprint("\n", outputFile);

		fprintf(outputFile, "\twhile (nextPoint[%d] < numPoints + 1) {\n", i - 1);
		for (int j = 0; j < pair.numSensors; j++) {
			if (pair.sensors[j].type == IME) {
				fprintf(outputFile, "\t\tint imeVal%d = -1;\n", pair.sensors[j].port);
				fprintf(outputFile, "\t\timeGet(%d, &imeVal%d);\n", pair.sensors[j].port, pair.sensors[j].port);
				fprint("\n", outputFile);
			}
		}

		fprint("\t\tif (", outputFile);
		for (int j = 0; j < pair.numSensors; j++) {
			if (j != 0) {
				fprint("\t\t\t", outputFile);
			}
			str = malloc(40 * sizeof(char));
			str[0] = 0;
			if (pair.sensors[i].type != IME) {
				getSensorGetFunc(pair, pair.sensors[j], j, str);
			} else {
				sprintf(str, "imeVal%d", pair.sensors[j].port);
			}
			// fprintf(outputFile, "abs(%s - points[nextPoint][%d]) < 10", str, pair.numPorts + i);
			fprintf(outputFile, "dir[%d] * abs(%s) > dir[%d] * (abs(points[nextPoint[%d]][%d] - (points[nextPoint[%d]][%d] >= 0 ? 1 : -1) * 5))",
					j, str, j, i - 1, pair.numPorts + i, i - 1, pair.numPorts + i);
			if (j < pair.numSensors - 1) {
				fprint(" &&\n", outputFile);
			} else {
				fprint(") {\n", outputFile);
			}
			free(str);
		}
		for (int j = 0; j < pair.numPorts; j++) {
			fprintf(outputFile, "\t\t\tmotorSet(%d, points[nextPoint[%d]][%d]);\n", pair.motorPorts[j], i - 1, j);
		}
		fprintf(outputFile, "\t\t\tnextPoint[%d]++;\n", i - 1);

		fprintf(outputFile, "\t\t\tif (nextPoint[%d] < numPoints + 1) {\n", i - 1);
		fprintf(outputFile, "\t\t\t\tfor (int i = 0; i < %d; i++) {\n", pair.numSensors);
		fprintf(outputFile, "\t\t\t\t\tdir[i] = (abs(points[nextPoint[%d]][%d + i]) - abs(points[nextPoint[%d] - 1][%d + i]) > 0 ? 1 : -1);\n",
				i - 1, pair.numPorts, i - 1, pair.numPorts);
		fprint("\t\t\t\t}\n", outputFile);
		fprint("\t\t\t}\n", outputFile);

		fprint("\t\t}\n", outputFile);
		fprint("\t\tdelay(20);\n", outputFile);
		fprint("\t}\n", outputFile);

		for (int j = 0; j < pair.numSensors; j++) {
			if (pair.sensors[j].type == TIME) {
				fprintf(outputFile, "\tstopTimer(%d);\n", pair.sensors[j].port);
			}
		}
		for (int j = 0; j < pair.numPorts; j++) {
			fprintf(outputFile, "\tmotorStop(%d);\n", pair.motorPorts[j]);
		}

		fprint("\tfor(int i = 0; i < numPoints + 1; i++) {\n", outputFile);
		fprint("\t\tfree(points[i]);\n", outputFile);
		fprint("\t}\n", outputFile);
		fprint("\tfree(points);\n", outputFile);
		fprint("\tfree(dir);\n", outputFile);

		fprint("}\n", outputFile);
		fprint("\n", outputFile);
	}
	delay(20);
}

void printConvenienceFunctions(void) {
	fprint("bool isRunning(void) {\n", outputFile);
	fprint("\tfor (int i = 1; i <= 10; i++) {\n", outputFile);
	fprint("\t\tif (motorGet(i) != 0) {\n", outputFile);
	fprint("\t\t\treturn true;\n", outputFile);
	fprint("\t\t}\n", outputFile);
	fprint("\t}\n", outputFile);
	fprint("\treturn false;\n", outputFile);
	fprint("}\n", outputFile);
	fprint("\n", outputFile);
	fprint("void waitThenDelay(int ms) {\n", outputFile);
	fprint("\twhile (isRunning()) {\n", outputFile);
	fprint("\t\tdelay(20);\n", outputFile);
	fprint("\t}\n", outputFile);
	fprint("\tdelay(ms);\n", outputFile);
	fprint("}\n", outputFile);
	fprint("\n", outputFile);
}

void printDefaultComment(void) {
	fprint("/*\n", outputFile);
	fprint(" * Runs the user autonomous code. This function will be started in its own task with the default\n", outputFile);
	fprint(" * priority and stack size whenever the robot is enabled via the Field Management System or the\n", outputFile);
	fprint(" * VEX Competition Switch in the autonomous mode. If the robot is disabled or communications is\n", outputFile);
	fprint(" * lost, the autonomous task will be stopped by the kernel. Re-enabling the robot will restart\n", outputFile);
	fprint(" * the task, not re-start it from where it left off.\n", outputFile);
	fprint(" *\n", outputFile);
	fprint(" * Code running in the autonomous task cannot access information from the VEX Joystick. However,\n", outputFile);
	fprint(" * the autonomous function can be invoked from another task if a VEX Competition Switch is not\n", outputFile);
	fprint(" * available, and it can access joystick information if called in this way.\n", outputFile);
	fprint(" *\n", outputFile);
	fprint(" * The autonomous task may exit, unlike operatorControl() which should never exit. If it does\n", outputFile);
	fprint(" * so, the robot will await a switch to another mode or disable/enable cycle.\n", outputFile);
	fprint(" */\n", outputFile);
	delay(20);
}

void printPointData(MoveNode *node, bool isRootNode) {
	// printf("doing point data for node %d\n\r", node->nodeId);
	fprintf(outputFile, "\tint **points%d = malloc(%d * sizeof(int *));\n", node->nodeId, node->numPoints + 1);
	fprintf(outputFile, "\tfor (int i = 0; i < %d; i++) {\n", node->numPoints + 1);
	fprintf(outputFile, "\t\tpoints%d[i] = malloc(%d * sizeof(int));\n", node->nodeId, pairMap[node->nPairId].numPorts + 1);
	fprint("\t}\n", outputFile);

	fprintf(outputFile, "\tpoints%d[0][0] = %d;\n", node->nodeId, node->numPoints);
	for (int i = 0; i < node->numPoints; i++) {
		fprint("\t", outputFile);
		for (int j = 0; j < pairMap[node->nPairId].numPorts; j++) {
			if (notAPatternIndex(i, node)) {
				fprintf(outputFile, "points%d[%d][%d] = %d, ", node->nodeId, i + 1, j, node->points[i].motPower[j]);
			} else {
				int patInd = getPattInd(i, node);
				fprintf(outputFile, "points%d[%d][%d] = %d, ", node->nodeId, i + 1, j,
						(int)(node->points[i].motPower[0] * pairMap[node->nPairId].pattern[patInd][j]));
			}
		}
		for (int j = 0; j < pairMap[node->nPairId].numSensors; j++) {
			fprintf(outputFile, "points%d[%d][%d] = %d", node->nodeId, i + 1, pairMap[node->nPairId].numPorts + j,
					node->points[i].endSensorVal[j]);
			if (j != pairMap[node->nPairId].numSensors - 1) {
				fprint(", ", outputFile);
			} else {
				fprint(";\n", outputFile);
			}
		}
	}
	fprintf(outputFile, "\tvoid *pass%d = (void *)(&points%d);\n", node->nodeId, node->nodeId);
	fprint("\n", outputFile);

	if (node->child != NULL) {
		printPointData(node->child, false);
	}

	if (node->sibling != NULL && !isRootNode) {
		printPointData(node->sibling, false);
	}
}

void ptabs(int numTabs) {
	for (int i = 0; i < numTabs; i++) {
		fprint("\t", outputFile);
	}
}

void printTaskSection(MoveNode *node, int numTabs) {
	static bool firstWrite = true;
	void printInnerTaskSection(MoveNode *parentNode, MoveNode *childNode, int numTabs) {
		/*printf("printing inner task section for node %d\n\r", childNode->nodeId);
		printNode(childNode);
		getchar();*/
		for (int i = 0; i < pairMap[parentNode->nPairId].numSensors; i++) {
			if (pairMap[parentNode->nPairId].sensors[i].type == IME) {
				ptabs(numTabs + 1);
				fprintf(outputFile, "int imeVal%d = -1;\n", pairMap[parentNode->nPairId].sensors[i].port);
				ptabs(numTabs + 1);
				fprintf(outputFile, "imeGet(%d, &imeVal%d);\n", pairMap[parentNode->nPairId].sensors[i].port, pairMap[parentNode->nPairId].sensors[i].port);
				fprint("\n", outputFile);
			}
		}
		char *str;
		ptabs(numTabs + 1);
		fprintf(outputFile, "if (nextPoint[%d] >= %d && ", parentNode->nPairId - 1, childNode->startPoint - 1);
		/*print("printed next point condition\n\r");
		getchar();*/
		for (int i = 0; i < pairMap[parentNode->nPairId].numSensors; i++) {
			str = malloc(30 * sizeof(char));
			str[0] = 0;
			if (pairMap[parentNode->nPairId].sensors[i].type != IME) {
				getSensorGetFunc(pairMap[parentNode->nPairId], pairMap[parentNode->nPairId].sensors[i], i, str);
			} else {
				sprintf(str, "imeVal%d", pairMap[parentNode->nPairId].sensors[i].port);
			}
			/*print("retrieved sensor value string\n\r");
			getchar();*/
			fprintf(outputFile, "abs(%s) %c abs(%d)",
					str, (abs(parentNode->points[childNode->startPoint].endSensorVal[i]) -
							abs(parentNode->points[childNode->startPoint - 1].endSensorVal[i]) >= 0
							? '>' : '<'),
							childNode->startVal[i]);
			/*print("printed sensor condition\n\r");
			getchar();*/
			if (i < pairMap[parentNode->nPairId].numSensors - 1) {
				fprint(" && ", outputFile);
			} else {
				fprint(") {\n", outputFile);
			}
			free(str);
		}
		printTaskSection(childNode, numTabs + 2);
		ptabs(numTabs + 1);
		fprint("}\n", outputFile);
		fprint("\n", outputFile);
		/*print("printed child task section\n\r");
		getchar();*/

		if (childNode->sibling != NULL) {
			printInnerTaskSection(parentNode, childNode->sibling, numTabs);
		}
	}

	if (numTabs == 1) {
		if (firstWrite) {
			fprint("\tbool ", outputFile);
			firstWrite = false;
		} else {
			fprint("\t", outputFile);
		}
		fprint("stillChecking = true;\n", outputFile);
	}

	/*printf("printing task section for node %d\n\r", node->nodeId);
	printNode(node);
	getchar();*/
	ptabs(numTabs);
	if (node->child != NULL || numTabs == 1 || node->sibling != NULL) {
		fprintf(outputFile, "TaskHandle run%d = ", node->nodeId);
	}
	fprintf(outputFile,
			"taskCreate(movePair%d, TASK_DEFAULT_STACK_SIZE / 2, pass%d, TASK_PRIORITY_DEFAULT);\n",
			node->nPairId, node->nodeId);
	/*ptabs(numTabs);
	fprint("delay(5);\n", outputFile);*/
	ptabs(numTabs);

	if (node->child != NULL) {
		fprintf(outputFile,
				"while ((taskGetState(run%d) == TASK_RUNNING || taskGetState(run%d) == TASK_RUNNABLE || \
				 \ntaskGetState(run%d) == TASK_SLEEPING) && stillChecking) {\n", node->nodeId, node->nodeId, node->nodeId);
		printInnerTaskSection(node, node->child, numTabs);
		ptabs(numTabs + 1);
		fprint("delay(5);\n", outputFile);
		ptabs(numTabs);
		fprint("}\n", outputFile);
		if (numTabs == 1) {
			int delayTime;
			if (node->sibling != NULL) {
				delayTime = node->sibling->startVal[0];
			} else {
				delayTime = 500;
			}
			fprintf(outputFile, "\twaitThenDelay(%d);\n", delayTime);
			if (node->sibling != NULL) {
				fprint("\t\n", outputFile);
			}
		}
	} else {
		if (numTabs == 1) {
			fprintf(outputFile,
					"while (taskGetState(run%d) == TASK_RUNNABLE || taskGetState(run%d) == TASK_SLEEPING) {\n",
					node->nodeId, node->nodeId);

			fprint("\t\tdelay(20);\n", outputFile);
			fprint("\t}\n", outputFile);
			int delayTime;
			if (node->sibling != NULL) {
				delayTime = node->sibling->startVal[0];
			} else {
				delayTime = 500;
			}
			fprintf(outputFile, "\twaitThenDelay(%d);\n", delayTime);
			fprint("\t\n", outputFile);
		} else {
			if (node->sibling == NULL) {
				fprint("stillChecking = false;\n", outputFile);
			}
		}
	}
}

void printChildData(MoveNode *node) {
	printPointData(node, true);
	/*printf("point data for node %d done\n\r", node->nodeId);
	getchar();*/
	printTaskSection(node, 1);
	/*printf("task section for node %d done\n\r", node->nodeId);
	getchar();*/

	if (node->sibling != NULL) {
		printChildData(node->sibling);
	}
}

void printNodes(void) {
	if (rootNode->child != NULL) {
		printChildData(rootNode->child);
	}
}

void createCodeFile(void) {
	printDebug("Creating code file!");
	outputFile = fopen("aGen.c", "w");

	printDebug("Printing header!");
	printLicense();
	printGenMessage();

	printDebug("Printing required functions!");
	printIncludes();
	printTimerLibrary();
	fprint("int *nextPoint;\n", outputFile);
	printGlobalSensors();
	printMotorPairs();
	printConvenienceFunctions();

	/*print("done");
	getchar();*/

	printDebug("Printing autonomous function!");
	printDefaultComment();
	fprint("void autonomous() {\n", outputFile);
	fprintf(outputFile, "\tnextPoint = malloc(%d * sizeof(int));\n", numPairs);
	fprintf(outputFile, "\tfor (int i = 0; i < %d; i++) {\n", numPairs);
	fprint("\t\tnextPoint[i] = -1;\n", outputFile);
	fprint("\t}\n", outputFile);
	fprint("\n", outputFile);
	printNodes();
	fprint("\tfree(nextPoint);\n", outputFile);
	fprint("}", outputFile);

	printDebug("Closing code file!");
	fclose(outputFile);
}

float getNextFloat(int *index, char *str) {
	// printDebug(str);
	// print(str);
	int val = 0;
	int powTen = -1;
	int count = 0;
	bool negative = false;
	while (count < 15) {
		// getchar();
		count++;
		char c = str[*index];
		// printf("%c %d %d\n\r", c, val, powTen);
		// delay(100);
		if (c == -1) {
			return 1337;
		}
		switch (c) {
		case '0':
			val = val * 10 + 0;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '1':
			val = val * 10 + 1;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '2':
			val = val * 10 + 2;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '3':
			val = val * 10 + 3;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '4':
			val = val * 10 + 4;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '5':
			val = val * 10 + 5;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '6':
			val = val * 10 + 6;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '7':
			val = val * 10 + 7;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '8':
			val = val * 10 + 8;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case '9':
			val = val * 10 + 9;
			powTen = (powTen == -1 ? powTen : powTen * 10);
			break;
		case ' ':
		case '\n':
		case 13:
			(*index)++;
			if (negative) {
				if (powTen == -1) {
					return (float)(-val);
				}
				return -((float)val / (float)powTen);
			}
			if (powTen == -1) {
				return (float)val;
			}
			// printf("%3.5f\n\r", (float)val / (float)powTen);
			// getchar();
			return ((float)val / (float)powTen);
		case '-':
			negative = true;
			break;
		case '.':
			powTen = 1;
			break;
		default:
			// return 1337;
			break;
		}
		(*index)++;
	}
	printError("Failed to find a value below 15 characters.");
	return 1337;
}

int getNextValue(int *index, char *str) {
	delay(1);
	/*print("new str: ");
	print(str);*/
	// printDebug(str);
	int speed = 0;
	int count = 0;
	bool negative = false;
	while (count < 10) {
		count++;
		char c = str[*index];
		/*printf("%c %d\n\r", c, (int)c);
		getchar();*/
		/*delay(100);*/
		if (c == -1) {
			print("hi");
			return 1337;
		}
		switch (c) {
		case '0':
			speed = speed * 10 + 0;
			break;
		case '1':
			speed = speed * 10 + 1;
			break;
		case '2':
			speed = speed * 10 + 2;
			break;
		case '3':
			speed = speed * 10 + 3;
			break;
		case '4':
			speed = speed * 10 + 4;
			break;
		case '5':
			speed = speed * 10 + 5;
			break;
		case '6':
			speed = speed * 10 + 6;
			break;
		case '7':
			speed = speed * 10 + 7;
			break;
		case '8':
			speed = speed * 10 + 8;
			break;
		case '9':
			speed = speed * 10 + 9;
			break;
		case ' ':
		case '\n':
		case 13:
			// getchar();
			(*index)++;
			if (negative) {
				return -speed;
			}
			return speed;
			break;
		case '-':
			negative = true;
			break;
		default:
			count--;
			// print("hi default");
			// return 1337;
			break;
		}
		(*index)++;
	}
	printError("Failed to find a value below 10 characters.");
	return 1337;
}

int getValue(char *str) {
	int zeroInd = 0;
	int* intPt = &zeroInd;
	return getNextValue(intPt, str);
}

/**
 * Please include extension in the name, it's a pain in the ass to code in an extension.
 */
void writeTreeToFile(char* name) {
	static bool detailPrint = false; // DEBUG;

	void writeNode(MoveNode *mn, FILE* file) {
		fprintf(file, "%d\n", mn->nodeId);
		fprintf(file, "%d\n", mn->nPairId);
		fprintf(file, "%d\n", mn->prevPairId);
		fprintf(file, "%d\n", mn->startPoint);

		if (detailPrint) {
			printf("%d %d %d %d\n\r", mn->nodeId, mn->nPairId, mn->prevPairId, mn->startPoint);
			print("Saved IDs.\n\r");
			getchar();
		}

		for (int i = 0; i < pairMap[mn->prevPairId].numSensors; i++) {
			fprintf(file, "%d", mn->startVal[i]);
			// printf("%d ", mn->startVal[i]);
			if (i == pairMap[mn->prevPairId].numSensors - 1) {
				fprint("\n", file);
				// print("\n\r");
			} else {
				fprint(" ", file);
			}
		}

		if (detailPrint) {
			print("Saved start vals.\n\r");
			getchar();
		}

		for (int i = 0; i < pairMap[mn->nPairId].numPatterns; i++) {
			fprintf(file, "%d\n", mn->numRanges[i]);
			// printf("%d\n\r", mn->numRanges[i]);
			for (int j = 0; j < mn->numRanges[i]; j++) {
				fprintf(file, "%d %d\n", mn->patternStartVals[i][j], mn->patternRangeLens[i][j]);
				// printf("%d %d\n\r", mn->patternStartVals[i][j], mn->patternRangeLens[i][j]);
			}
		}

		if (detailPrint) {
			print("Saved pattern data.\n\r");
			getchar();
		}

		fprintf(file, "%d\n", mn->numPoints);
		// printf("Num points: %d\n\r", mn->numPoints);
		for (int i = 0; i < mn->numPoints; i++) {
			if (notAPatternIndex(i, mn)) {
				for (int j = 0; j < pairMap[mn->nPairId].numPorts; j++) {
					fprintf(file, "%d", mn->points[i].motPower[j]);
					// printf("%d ", mn->points[i].motPower[j]);
					if (j == pairMap[mn->nPairId].numPorts - 1) {
						fprint("\n", file);
						// print("\n\r");
					} else {
						fprint(" ", file);
					}
				}
			} else {
				fprintf(file, "%d\n", mn->points[i].motPower[0]);
				// printf("%d\n\r", mn->points[i].motPower[0]);
			}
			// getchar();
			for (int j = 0; j < pairMap[mn->nPairId].numSensors; j++) {
				fprintf(file, "%d", mn->points[i].endSensorVal[j]);
				// printf("%d ", mn->points[i].endSensorVal[j]);
				if (j == pairMap[mn->nPairId].numSensors - 1) {
					fprint("\n", file);
					// print("\n\r");
				} else {
					fprint(" ", file);
				}
			}
			// getchar();
		}

		if (detailPrint) {
			print("Saved point data.\n\r");
			getchar();
		}

		if (mn->child != NULL) {
			fprintf(file, "%d\n", mn->child->nodeId);
			// printf("%d\n\r", mn->child->nodeId);
		} else {
			fprint("-1\n", file);
			// print("-1\n\r");
		}

		if (mn->sibling != NULL) {
			fprintf(file, "%d\n", mn->sibling->nodeId);
			// printf("%d\n\r", mn->sibling->nodeId);
		} else {
			fprint("-1\n", file);
			// print("-1\n\r");
		}

		if (detailPrint) {
			printf("Saved node %d.\n\r", mn->nodeId);
			getchar();
		}

		if (DEBUG) {
			lcdPrint(uart2, 1, "Node %d done.", mn->nodeId);
			while (lcdReadButtons(uart2) == 0) {
				delay(20);
			}
		}

		if (mn->child != NULL) {
			writeNode(mn->child, file);
		}

		if (mn->sibling != NULL) {
			writeNode(mn->sibling, file);
		}
	}

	FILE *dataFile = fopen(name, "w");
	if (dataFile == NULL) {
		printError("Failed to create new data file.");
		return;
	}
	fprintf(dataFile, "%d\n", numPairs);
	for (int i = 0; i < numPairs; i++) {
		MotorSensorPair pair = pairMap[i];
		//fprintf(dataFile, "%d\n", pair.pairId);
		if (pair.pairStr == NULL) {
			fprint("NULL\n", dataFile);
		} else {
			fprintf(dataFile, "%s\n", pair.pairStr);
		}
		fprintf(dataFile, "%d\n", pair.numPorts);
		for (int j = 0; j < pair.numPorts; j++) {
			fprintf(dataFile, "%d", pair.motorPorts[j]);
			if (j == pair.numPorts - 1) {
				fprint("\n", dataFile);
			} else {
				fprint(" ", dataFile);
			}
		}
		fprintf(dataFile, "%d\n", pair.numSensors);
		for (int j = 0; j < pair.numSensors; j++) {
			fprintf(dataFile, "%d %d\n", pair.sensors[j].type, pair.sensors[j].port);
		}
		fprintf(dataFile, "%d\n", pair.numPatterns);
		for (int j = 0; j < pair.numPatterns; j++) {
			fprintf(dataFile, "%d\n", pair.basePattInds[j]);
		}
		for (int j = 0; j < pair.numPatterns; j++) {
			for (int k = 0; k < pair.numPorts; k++) {
				fprintf(dataFile, "%3.5f", pair.pattern[j][k]);
				if (k == pair.numPorts - 1) {
					fprint("\n", dataFile);
				} else {
					fprint(" ", dataFile);
				}
			}
		}
	}

	if (DEBUG) {
		lcdSetText(uart2, 1, "Pairs done.");
		while (lcdReadButtons(uart2) == 0) {
			delay(20);
		}
	}

	if (detailPrint) {
		print("Pairs written.\n\r");
		getchar();
	}

	writeNode(rootNode->child, dataFile);
	fclose(dataFile);

	if (detailPrint) {
		print("Finished writing everything.\n\r");
		getchar();
	}

	if (DEBUG) {
		lcdSetText(uart2, 1, "Done writing");
		while (lcdReadButtons(uart2) == 0) {
			delay(20);
		}
	}

	if (!DEBUG) {
		gotoxy(0, 6);
		print("Finished writing to file.");
		delay(1000);
		gotoxy(0, 6);
		print("                              ");
		movedCursor = true;
	} else {
		printDebug("Finished writing to file.");
	}
}

void placeNodeInTree(MoveNode *node) {
	void findRelation(MoveNode *relatedNode, int targetId) {
		if (relatedNode->sibling != NULL) {
			if (relatedNode->sibling->nodeId == targetId) {
				free(relatedNode->sibling);
				if (DEBUG) {
					print("Found match!");
				}
				relatedNode->sibling = node;
				return;
			}

			if (relatedNode->sibling->nodeId < targetId) {
				findRelation(relatedNode->sibling, targetId);
			}
		}

		if (relatedNode->child != NULL) {
			if (relatedNode->child->nodeId == targetId) {
				free(relatedNode->child);
				if (DEBUG) {
					print("Found match!");
				}
				relatedNode->child = node;
				return;
			}
			findRelation(relatedNode->child, targetId);
		}

		// printError("Failed to find match.");
	}

	findRelation(rootNode, node->nodeId);
}

/**
 * Given full filename, loads a stored autonomous path from ROM into RAM memory.
 */
void loadTree(char* filePrefix, bool restart) {
	static bool detailPrint = false; // = DEBUG;
	static int numFile = 0;

	if (restart) {
		numFile = 0;
	}

	numFile++;
	char *name = malloc(8 * sizeof(char));
	snprintf(name, 8, "%s%d.dat", filePrefix, numFile);

	/*if (numFile > 1 || restart) {
		detailPrint = true;
	} else {
		detailPrint = false;
	}*/

	FILE *dataFile = fopen(name, "r");
	if (dataFile == NULL) {				// check if the file exists
		numFile--;
		printError("File doesn't exist!");
		return;
	}

	restartTree();
	totalTreeSize = 0;
	/*print("Restarted tree.\n\r");
	getchar();*/

	char *intBuffer = malloc(sizeof(char) * 6);
	fgets(intBuffer, 6, dataFile);
	int numPairsToRead = getValue(intBuffer);	// read the number of pairs to read
	free(intBuffer);

	if (numFile == 1 && !restart) {
		freePairs();
	}
	if (detailPrint) {
		print("Cleared all init pairs.\n\r");
		getchar();
	}
	totalTreeSize = 0;
	for (int i = 0; i < numPairsToRead; i++) {
		MotorSensorPair *newPair;
		if (numFile == 1 && !restart) {
			newPair = initNewPair();
		} else {
			newPair = &pairMap[i];
		}
		char *pairName = malloc(sizeof(char) * 21);
		fgets(pairName, 21, dataFile);			// get the name to be displayed
		pairName[strlen(pairName) - 2] = '\0';	// satisfy the C string requirement
		newPair->pairStr = pairName;

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);			// get number of ports in a pair
		int numPorts = getValue(intBuffer);
		free(intBuffer);

		if (detailPrint) {
			printf("Loaded num ports: %d.\n\r", numPorts);
			getchar();
		}

		int zeroInd = 0;
		int *intPt = &zeroInd;
		intBuffer = malloc(sizeof(char) * numPorts * 6);
		fgets(intBuffer, numPorts * 6, dataFile);
		for (int j = 0; j < numPorts; j++) {
			int port = getNextValue(intPt, intBuffer);
			if (numFile == 1 && !restart) {
				addMotor(newPair, port);
			}
		}
		free(intBuffer);

		if (detailPrint) {
			print("Motors added.\n\r");
			getchar();
		}

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		int numSensors = getValue(intBuffer);
		free(intBuffer);

		for (int j = 0; j < numSensors; j++) {
			*intPt = 0;
			intBuffer = malloc(sizeof(char) * numSensors * 7);
			fgets(intBuffer, numSensors * 7, dataFile);

			int type = getNextValue(intPt, intBuffer);
			int port = getNextValue(intPt, intBuffer);
			if (numFile == 1 && !restart) {
				addSensor(newPair, type, port);
			}
		}
		free(intBuffer);

		if (detailPrint) {
			print("Sensors added.\n\r");
			getchar();
		}

		if (newPair->pattern != NULL) {
			for (int j = 0; j < newPair->numPatterns; j++) {
				free(newPair->pattern[j]);
			}
			free(newPair->basePattInds);
			free(newPair->pattern);
		}

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		newPair->numPatterns = getValue(intBuffer);
		free(intBuffer);

		if (detailPrint) {
			print("Loaded num patterns.\n\r");
			getchar();
		}

		newPair->basePattInds = malloc(newPair->numPatterns * sizeof(*(newPair->basePattInds)));
		for (int j = 0; j < newPair->numPatterns; j++) {
			intBuffer = malloc(sizeof(char) * 6);
			fgets(intBuffer, 6, dataFile);
			newPair->basePattInds[j] = getValue(intBuffer);
			free(intBuffer);
		}

		if (detailPrint) {
			print("Loaded base indices.\n\r");
			getchar();
		}

		newPair->pattern = malloc(newPair->numPatterns * sizeof(*(newPair->pattern)));
		for (int j = 0; j < newPair->numPatterns; j++) {
			*intPt = 0;
			intBuffer = malloc(sizeof(char) * numPorts * 12);
			// printf("%d\n\r", numPorts);
			fgets(intBuffer, numPorts * 12, dataFile);
			// print(intBuffer);
			newPair->pattern[j] = malloc(numPorts * sizeof(*(newPair->pattern[j])));
			for (int k = 0; k < numPorts; k++) {
				newPair->pattern[j][k] = getNextFloat(intPt, intBuffer);
				if (detailPrint) {
					printf("Loaded float: %3.2f\n\r", newPair->pattern[j][k]);
					getchar();
				}
			}
			free(intBuffer);
		}

		totalTreeSize += getPairSize(*newPair);

		intPt = NULL;
		pairName = NULL;
		newPair = NULL;
	}

	for (int i = 0; i < numPairs; i++) {
		printPair(&pairMap[i]);
		if (detailPrint) {
			getchar();
		}
	}
	restartTree();
	// getchar();
	if (detailPrint) {
		print("Pairs loaded.\n\r");
		getchar();
	}
	/*print("Pairs loaded.\n\r");
	getchar();*/
	redrawDisplay = false;
	if (detailPrint) {
		print("Restarted tree.\n\r");
		getchar();
	}
	// detailPrint = true;
	rootNode->child = malloc(sizeof(MoveNode));
	rootNode->child->nodeId = 1;
	while (feof(dataFile) == 0) {
		MoveNode *newNode = malloc(sizeof(MoveNode));
		if (newNode == NULL) {
			printError("Failed to initialize node.");
		}

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		newNode->nodeId = getValue(intBuffer);
		free(intBuffer);

		if (detailPrint) {
			printf("Loading node %d.\n\r", newNode->nodeId);
			getchar();
		}

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		newNode->nPairId = getValue(intBuffer);
		free(intBuffer);

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		newNode->prevPairId = getValue(intBuffer);
		free(intBuffer);

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		newNode->startPoint = getValue(intBuffer);
		free(intBuffer);

		if (detailPrint) {
			print("Loaded IDs.\n\r");
			getchar();
		}

		newNode->startVal = malloc(pairMap[newNode->prevPairId].numSensors * sizeof(*(newNode->startVal)));
		int zeroInd = 0;
		int *intPt = &zeroInd;
		intBuffer = malloc(sizeof(char) * pairMap[newNode->prevPairId].numSensors * 7);
		fgets(intBuffer, pairMap[newNode->prevPairId].numSensors * 7, dataFile);
		for (int i = 0; i < pairMap[newNode->prevPairId].numSensors; i++) {
			newNode->startVal[i] = getNextValue(intPt, intBuffer);
		}

		if (detailPrint) {
			print("Loaded start vals.\n\r");
			getchar();
		}

		int numPatts = pairMap[newNode->nPairId].numPatterns;
		newNode->numRanges = malloc(numPatts * sizeof(*(newNode->numRanges)));
		newNode->patternStartVals = malloc(numPatts * sizeof(*(newNode->patternStartVals)));
		newNode->patternRangeLens = malloc(numPatts * sizeof(*(newNode->patternRangeLens)));
		for (int i = 0; i < numPatts; i++) {
			intBuffer = malloc(sizeof(char) * 6);
			fgets(intBuffer, 6, dataFile);
			newNode->numRanges[i] = getValue(intBuffer);
			free(intBuffer);

			if (newNode->numRanges[i] > 0) {
				newNode->patternStartVals[i] = malloc(newNode->numRanges[i] * sizeof(*(newNode->patternStartVals[i])));
				newNode->patternRangeLens[i] = malloc(newNode->numRanges[i] * sizeof(*(newNode->patternRangeLens[i])));
			} else {
				newNode->patternStartVals[i] = NULL;
				newNode->patternRangeLens[i] = NULL;
			}

			for (int j = 0; j < newNode->numRanges[i]; j++) {
				zeroInd = 0;
				intPt = &zeroInd;
				int MAX_SIZE = newNode->numRanges[i] * 8;
				intBuffer = malloc(sizeof(char) * MAX_SIZE);
				fgets(intBuffer, MAX_SIZE, dataFile);
				newNode->patternStartVals[i][j] = getNextValue(intPt, intBuffer);
				newNode->patternRangeLens[i][j] = getNextValue(intPt, intBuffer);
				free(intBuffer);
			}
		}

		if (detailPrint) {
			printf("Loaded patterns: %d\n\r", numPatts);
			getchar();
		}

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		newNode->numPoints = getValue(intBuffer);
		free(intBuffer);

		newNode->points = malloc(sizeof(*(newNode->points)) * newNode->numPoints);
		// printf("%d\n\r", newNode->numPoints);
		for (int i = 0; i < newNode->numPoints; i++) {
			if (notAPatternIndex(i, newNode)) {
				newNode->points[i].motPower = malloc(sizeof(*(newNode->points[i].motPower)) * pairMap[newNode->nPairId].numPorts);
				zeroInd = 0;
				intPt = &zeroInd;
				int MAX_SIZE = pairMap[newNode->nPairId].numPorts * 6;
				intBuffer = malloc(sizeof(char) * MAX_SIZE);
				fgets(intBuffer, MAX_SIZE, dataFile);
				for (int j = 0; j < pairMap[newNode->nPairId].numPorts; j++) {
					newNode->points[i].motPower[j] = getNextValue(intPt, intBuffer);
				}
			} else {
				newNode->points[i].motPower = malloc(sizeof(*(newNode->points[i].motPower)));
				intBuffer = malloc(sizeof(char) * 7);
				fgets(intBuffer, 7, dataFile);
				newNode->points[i].motPower[0] = getValue(intBuffer);
			}
			free(intBuffer);

			// print("loaded motor speeds\n\r");

			newNode->points[i].endSensorVal = malloc(sizeof(*(newNode->points[i].endSensorVal)) * pairMap[newNode->nPairId].numSensors);
			zeroInd = 0;
			intPt = &zeroInd;
			int MAX_SIZE = pairMap[newNode->nPairId].numSensors * 8;
			intBuffer = malloc(sizeof(char) * MAX_SIZE);
			fgets(intBuffer, MAX_SIZE, dataFile);
			for (int j = 0; j < pairMap[newNode->nPairId].numSensors; j++) {
				newNode->points[i].endSensorVal[j] = getNextValue(intPt, intBuffer);
			}
			free(intBuffer);
		}

		if (detailPrint) {
			print("Loaded points data.\n\r");
			getchar();
		}

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		int childId = getValue(intBuffer);
		free(intBuffer);

		if (childId == -1) {
			newNode->child = NULL;
		} else {
			newNode->child = malloc(sizeof(MoveNode));
			newNode->child->nodeId = childId;
		}

		intBuffer = malloc(sizeof(char) * 6);
		fgets(intBuffer, 6, dataFile);
		int siblingId = getValue(intBuffer);
		free(intBuffer);

		if (siblingId == -1) {
			newNode->sibling = NULL;
		} else {
			newNode->sibling = malloc(sizeof(MoveNode));
			newNode->sibling->nodeId = siblingId;
		}

		if (detailPrint) {
			print("Loaded relatives' IDs.\n\r");
			getchar();
		}

		totalTreeSize += getNodeSize(newNode);
		lastUniqueId = newNode->nodeId + 1;
		placeNodeInTree(newNode);

		intPt = NULL;
		intBuffer = NULL;
		newNode = NULL;
	}

	if (detailPrint) {
		print("Done loading.");
		getchar();
	}

	fclose(dataFile);
	if (!DEBUG) {
		gotoxy(0, 6);
		print("Finished loading from file.");
		delay(1000);
		gotoxy(0, 6);
		print("                              ");
		movedCursor = true;
	} else {
		print("Finished loading from file.");
	}
	redrawDisplay = true;
}

void loadTreeFromStart(char *filePrefix) {
	loadTree(filePrefix, true);
}

void loadTreeFromFile(char *filePrefix) {
	loadTree(filePrefix, false);
}
