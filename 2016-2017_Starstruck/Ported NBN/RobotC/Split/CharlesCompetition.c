#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    Expander,       sensorAnalog)
#pragma config(Sensor, in8,    Sel,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  QuadL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  QuadR,          sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  Sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  SonarL,         sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  SonarR,         sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  SQuad_R,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  SQuad_L,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           W_LF,          tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port2,           W_RF,          tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port3,           W_HF,          tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           INTAKE,        tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port5,           S_L,           tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           S_R,           tmotorVex393, openLoop)
#pragma config(Motor,  port7,           CON,           tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           W_HB,          tmotorVex393, openLoop)
#pragma config(Motor,  port9,           W_LB,          tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port10,          W_RB,          tmotorVex393HighSpeed, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

//Includes
#include "Vex_Competition_Includes.c"

#include "CharlesLib.h"

//#include "SmartMotorLib.c"
#include "CharlesLib.c"

//====================================//

void pre_auton() {
	bStopTasksBetweenModes = false; //Keep custom tasks running when mode switched
	bLCDBacklight = true;

	StartTask(lcdMenu);

	//fpsPrintMap();
}

//========================================================//
//           DRIVER
//========================================================//

task usercontrol() {
	StopTask(autonomous);
	while(true) {
		//lcdDisplayVoltage();//TODO: Check if comp switch is plugged in
		joystickMap();
	}
}


void joystickMap() {
  joyRefreshAnalog();

  if(!vexRT[Btn5D] && !vexRT[Btn5U]) {
  	joyMapMain();
  }
  buttonMapMain();

  joyMapPartner();
  buttonMapPartner();
}

//========================================================//
//           BACKGROUND
//========================================================//

task shooterPID() {
	while(true) {
		wait10Msec(2);
		if(shooter==0) {
			shooterSetDirect();
			speedL=0;
			speedR=0;
			shooterOld = 0;
			continue;
		}//Do not run calculations if shooter is being stopped

		if(errL>50 || errR>50 || shooterOld!=shooter) {
			speedL = shooter;
			speedR = shooter+5;//BS Fix for mech diff
			shooterOld = shooter;
			shooterSetDirect((int)speedL, (int)speedR);
			wait10Msec(100);
		}

		//PID to value
		if(!abs(errL)<PID_THRESH){
			if(abs(errL)>40){
				speedL += bsFix*((errL/Kp)*abs(errL));//TODO: Scale this properly
			}else{
				speedL += ((errL/Kp)*abs(errL));
			}
			wait10Msec(2);
		}

		if(!abs(errR)<PID_THRESH){
			if(abs(errR)>40){
				speedR += bsFix*((errR/Kp)*abs(errR));
			}else{
				speedR += ((errR/Kp)*abs(errR));
			}
			//Set speed proportional to error
			wait10Msec(2);
		}//If the shooter speed is within threshhold ange of trget, maintain speed

		//Integral and Derivative not Implemented

		if(speedL>=127) {
			speedL=127;
		}
		if(speedR>=127) {
			speedR=127;
		}
		if(speedL<=0) {
			speedL = 0;
		}
		if(speedR<=0) {
			speedR = 0;
		}//Safeguard for reducing to low speeds (otherwise motors may run backwards)

		//Set motors to calculated speed
		shooterSetDirect(speedL, speedR);
	}
}

//========================================================//
//           AUTON
//========================================================//
task autonomous() {
	StopTask(usercontrol);

	intakeSet();

	// Potentiometer selector is "VEX" side up

	//encoderReset();
	nMotorEncoder[QuadL]=0;
	//9490 Lift Auton
	if(SensorValue[Sel]==4095){
		driveSet(127,127);
		while(1);
	}

	//Stationary Auton
	else if(SensorValue[Sel] <= 2047){ // left of the potentiometer
		shooterSetDirect(SensorValue[Sel]/10,SensorValue[Sel]/10); //change back to 100 after skills

		intakeSet();
		conveyorSet();
		wait10Msec(300);//3 Sec Delay for ramp-up
		intakeSet(100);
		conveyorSet(127);
	}

	//Mobile Auton
	else if(SensorValue[Sel] > 2047){ // right of the potentiometer
		beep();
		intakeSet();

		int sonarDistance = 62; //maybe change to 54
		int encoderThresh = 800;

		shooterSetDirect(90,90); //TODO: re-benchmark this speed!! with the sonarDistance!!

		//Run forward approximate distance using encoder
		//do{
		int i;
		for(i = 0; i<=100;i+=2) {
			driveSet(i,i);
			wait10Msec(2);
		}
		wait10Msec(150);
		//}while(abs(nMotorEncoder[QuadL])<encoderThresh);// && (abs(EncoderGetValue(W_RF))<encoderThresh));

		driveSet();
		wait10Msec(50);

		//Lock into shooting distance using ultrasonic
		float err = 0;
		timeElapsed = 0;

		do{
			err = sonarDistance-SensorValue[Sonar];
			if(abs(err)<=AUTON_PID_THRESH){
				timeElapsed++;
				continue;
			}

			driveSetByDistance(sonarDistance);

		}while(timeElapsed<2000);

		driveSet(0,0);

		beep(); //beeps when it stops
		wait10Msec(1);
		beep();
		wait10Msec(1);
		beep();
		wait10Msec(1);
		boop();

		intakeSet(60);
		conveyorSet(50);
		wait1Msec(750);
		conveyorSet(0);
		wait1Msec(750);
		conveyorSet(50);
		wait1Msec(750);
		conveyorSet(0);
		wait1Msec(750);
		conveyorSet(50);


		//success(); not written yet lol

		/*
		//gyro PID

		SetMotor(S_TL);
		SetMotor(S_BL);
		SetMotor(S_TR);
		SetMotor(S_BR);

		EncoderSetValue(W_LF,0);
		EncoderSetValue(W_RF,0);

		sonarDistance = 30; //distance it should be from goal pole to turn accurately
													 //needs to be tweaked
		SensorValue[Gyro] = 0;
		encoderThresh=100; //smaller bc small distance, needs to be tweaked
											 //needs to be tweaked
		timeElapsed = 0;

		wait10Msec(50);
		do{
			err = sonarDistance-SensorValue[Sonar];
			if(abs(err)<AUTON_PID_THRESH){
				SetMotor(W_LF);
				SetMotor(W_LB);
				SetMotor(W_RF);
				SetMotor(W_RB);
				timeElapsed++;
				continue;
			}

			K = 15;
			err=(err>0)?-K-err:K-err;
				SetMotor(W_LF,-err);
				SetMotor(W_LB,err);
				SetMotor(W_RF,err);
				SetMotor(W_RB,err);

		}while(timeElapsed<2000);

		beep(); //beeps when it stops

		//TURNING

		int angle = 900; //gyro is measure in 1/10ths of degrees

		timeElapsed = 0;
		SensorValue[Gyro] = 0;
		EncoderSetValue(W_LF);
		//EncoderSetValue(W_RF);

		beep();
		SensorValue[Gyro] = 0;
		do{
			float err=-angle-SensorValue[Gyro];
			shooter = 0;
			if(abs(err)<AUTON_PID_THRESH){
				SetMotor(W_LF);
				SetMotor(W_LB);
				SetMotor(W_RF);
				SetMotor(W_RB);
				timeElapsed++;
				continue;
			}

			//K = 0.8;
			err= err*K;
				SetMotor(W_LF,(int)err);
				SetMotor(W_LB,(int)-err);
				SetMotor(W_RF,(int)err);
				SetMotor(W_RB,(int)err);

		}while(timeElapsed<400);
		beep();
		*/
	}
}
